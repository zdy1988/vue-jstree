<template>
    <div :class="classes" role="tree" onselectstart="return false">
        <ul :class="containerClasses" role="group">
            <tree-item v-for="(child, index) in data"
                       :key="index"
                       :data="child"
                       :text-field-name="textFieldName"
                       :value-field-name="valueFieldName"
                       :children-field-name="childrenFieldName"
                       :item-events="itemEvents"
                       :whole-row="wholeRow"
                       :show-checkbox="showCheckbox"
                       :allow-transition="allowTransition"
                       :height="sizeHeight"
                       :parent-item="data"
                       :draggable="draggable"
                       :drag-over-background-color="dragOverBackgroundColor"
                       :on-item-click="onItemClick"
                       :on-item-toggle="onItemToggle"
                       :on-item-drag-start="onItemDragStart"
                       :on-item-drag-end="onItemDragEnd"
                       :on-item-drop="onItemDrop"
                       :klass="index === data.length-1?'tree-last':''">
                <template slot-scope="_">
                    <slot :vm="_.vm" :model="_.model">
                        <i :class="_.vm.themeIconClasses" role="presentation" v-if="!_.model.loading"></i>
                        <span v-html="_.model[textFieldName]"></span>
                    </slot>
                </template>
                <template slot="itemActions" slot-scope="_">
                    <slot name="itemActions" :item="_.item" :vm="_.vm"></slot>
                </template>
            </tree-item>
        </ul>
    </div>
</template>
<script>
    import TreeItem from './tree-item.vue'

    let ITEM_ID = 0
    let ITEM_HEIGHT_SMALL = 18
    let ITEM_HEIGHT_DEFAULT = 24
    let ITEM_HEIGHT_LARGE = 32

    export default {
        name: 'VJstree',
        props: {
            data: {type: Array},
            size: {type: String, validator: value => ['large', 'small'].indexOf(value) > -1},
            showCheckbox: {type: Boolean, default: false},
            wholeRow: {type: Boolean, default: false},
            noDots: {type: Boolean, default: false},
            collapse: {type: Boolean, default: false},
            multiple: {type: Boolean, default: false},
            allowBatch: {type: Boolean, default: false},
            allowTransition: {type: Boolean, default: true},
            textFieldName: {type: String, default: 'text'},
            valueFieldName: {type: String, default: 'value'},
            childrenFieldName: {type: String, default: 'children'},
            orderFieldName: {type: String, default: ''},
            itemEvents: {
                type: Object, default: function () {
                    return {}
                }
            },
            async: {type: Function},
            canDrop: {type: Function, default: () => true},
            loadingText: {type: String, default: 'Loading...'},
            draggable: {type: Boolean, default: false},
            dragOverBackgroundColor: {type: String, default: "#C9FDC9"},
            klass: String
        },
        data() {
            return {
                draggedItem: undefined,
                draggedElm: undefined
            }
        },
        computed: {
            classes() {
                return [
                    {'tree': true},
                    {'tree-default': !this.size},
                    {[`tree-default-${this.size}`]: !!this.size},
                    {'tree-checkbox-selection': !!this.showCheckbox},
                    {[this.klass]: !!this.klass}
                ]
            },
            containerClasses() {
                return [
                    {'tree-container-ul': true},
                    {'tree-children': true},
                    {'tree-wholerow-ul': !!this.wholeRow},
                    {'tree-no-dots': !!this.noDots}
                ]
            },
            sizeHeight() {
                switch (this.size) {
                    case 'large':
                        return ITEM_HEIGHT_LARGE
                    case 'small':
                        return ITEM_HEIGHT_SMALL
                    default:
                        return ITEM_HEIGHT_DEFAULT
                }
            }
        },
        methods: {
            initializeData(items) {
                if (items && items.length > 0) {
                    for (let i in items) {
                        var dataItem = this.initializeDataItem(items[i])
                        items[i] = dataItem
                        this.initializeData(items[i][this.childrenFieldName])
                    }
                }
            },
            initializeDataItem(item) {
                function Model(item, textFieldName, valueFieldName, childrenFieldName, collapse) {
                    this.id = item.id || ITEM_ID++
                    this[textFieldName] = item[textFieldName] || ''
                    this[valueFieldName] = item[valueFieldName] || item[textFieldName]
                    this.canDrop = item.canDrop || true,//this.canDrop(item),
                    this.icon = item.icon || ''
                    this.opened = item.opened || collapse
                    this.selected = item.selected || false
                    this.disabled = item.disabled || false
                    this.loading = item.loading || false
                    this[childrenFieldName] = item[childrenFieldName] || []
                }

                let node = Object.assign(new Model(item, this.textFieldName, this.valueFieldName, this.childrenFieldName, this.collapse), item)
                let self = this
                node.addBefore = function (data, selectedNode) {
                    let newItem = self.initializeDataItem(data)
                    let index = selectedNode.parentItem.findIndex(t => t.id === node.id)
                    selectedNode.parentItem.splice(index, 0, newItem)
                }
                node.addAfter = function (data, selectedNode) {
                    let newItem = self.initializeDataItem(data)
                    let index = selectedNode.parentItem.findIndex(t => t.id === node.id) + 1
                    selectedNode.parentItem.splice(index, 0, newItem)
                }
                node.addChild = function (data) {
                    let newItem = self.initializeDataItem(data)
                    node.opened = true
                    node[self.childrenFieldName].push(newItem)
                }
                node.openChildren = function () {
                    node.opened = true
                    self.handleRecursionNodeChildren(node, node => {
                        node.opened = true
                    })
                }
                node.closeChildren = function () {
                    node.opened = false
                    self.handleRecursionNodeChildren(node, node => {
                        node.opened = false
                    })
                }
                node.moveLeftTo = function(draggedItem, anchorNode, oriIndex){


                    draggedItem.parentItem.splice(draggedItem.index, 1)
                    anchorNode.parentItem.splice(oriIndex, 0, draggedItem.item);

                }
                node.moveRightTo = function(draggedItem, anchorNode, oriIndex){

                    draggedItem.parentItem.splice(draggedItem.index, 1)
                    anchorNode.parentItem.splice(oriIndex+1, 0, draggedItem.item);


                }
                return node
            },
            initializeLoading() {
                var item = {}
                item[this.textFieldName] = this.loadingText
                item.disabled = true
                item.loading = true
                return this.initializeDataItem(item)
            },
            handleRecursionNodeChilds(node, func) {
                if (func(node) !== false) {
                    if (node.$children && node.$children.length > 0) {
                        for (let childNode of node.$children) {
                            if (!childNode.disabled) {
                                this.handleRecursionNodeChilds(childNode, func)
                            }
                        }
                    }
                }
            },
            handleRecursionNodeChildren(node, func) {
                if (func(node) !== false) {
                    if (node[this.childrenFieldName] && node[this.childrenFieldName].length > 0) {
                        for (let childNode of node[this.childrenFieldName]) {
                            this.handleRecursionNodeChildren(childNode, func)
                        }
                    }
                }
            },
            onItemClick(oriNode, oriItem, e) {
                if (this.multiple) {
                    if (this.allowBatch) {
                        this.handleBatchSelectItems(oriNode, oriItem)
                    }
                } else {
                    this.handleSingleSelectItems(oriNode, oriItem)
                }
                this.$emit('item-click', oriNode, oriItem, e)
            },
            handleSingleSelectItems(oriNode, oriItem) {
                this.handleRecursionNodeChilds(this, node => {
                    if (node.model) node.model.selected = false
                })
                oriNode.model.selected = true
            },
            handleBatchSelectItems(oriNode, oriItem) {
                this.handleRecursionNodeChilds(oriNode, node => {
                    if (node.model.disabled) return
                    node.model.selected = oriNode.model.selected
                })
            },
            onItemToggle(oriNode, oriItem, e) {
                if (oriNode.model.opened) {
                    this.handleAsyncLoad(oriNode.model[this.childrenFieldName], oriNode, oriItem)
                }
                this.$emit('item-toggle', oriNode, oriItem, e)
            },
            handleAsyncLoad(oriParent, oriNode, oriItem) {
                var self = this
                if (this.async) {
                    if (oriParent[0].loading) {
                        this.async(oriNode, (data) => {
                            if (data.length > 0) {
                                for (let i in data) {
                                    if (!data[i].isLeaf) {
                                        if (typeof data[i][self.childrenFieldName] !== "object") {
                                            data[i][self.childrenFieldName] = [self.initializeLoading()]
                                        }
                                    }
                                    var dataItem = self.initializeDataItem(data[i])
                                    self.$set(oriParent, i, dataItem)
                                }
                            } else {
                                oriNode.model[self.childrenFieldName] = []
                            }
                        })
                    }
                }
            },
            onItemDragStart(e, oriNode, oriItem) {
                if (!this.draggable || oriItem.dragDisabled)
                    return false
                e.dataTransfer.effectAllowed = "move"
                e.dataTransfer.setData('text', null)
                this.draggedElm = e.target
                this.draggedItem = {
                    item: oriItem,
                    parentItem: oriNode.parentItem,
                    index: oriNode.parentItem.findIndex(t => t.id === oriItem.id)
                }


                this.$emit("item-drag-start", oriNode, oriItem,this.draggedItem, e)
            },
            onItemDragEnd(e, oriNode, oriItem) {
                this.draggedItem = undefined
                this.draggedElm = undefined
                this.$emit("item-drag-end", oriNode, oriItem, e)
            },
            allowedToDrop (oriItem, position) {
                if (!this.draggable || !this.draggedItem) {
                    return false
                }
                if (position === '2' && oriItem.canDrop === false) return false
                if (this.draggedItem.parentItem === oriItem.children ||
                    this.draggedItem.item === oriItem ||
                    // (oriItem.children && oriItem.children.indexOf(this.draggedItem.item) !== -1) ||
                    (this.draggedItem.item.children && this.draggedItem.item.children.indexOf(oriItem) !== -1)) {
                    return false
                }
                return true
            },
            replaceDataItem (item, replacement) {
                var id = item[this.childrenFieldName]
                var index = _.indexOf(this.data, _.find(this.data, { [this.childrenFieldName]: id }))
                if (!Object.isFrozen(this.data)) {
                    this.loadDataOnWatch = false
                    if (index !== -1) {
                        this.data.splice(index, 1, _.merge({}, this.data[index], replacement))
                    } else if (item.item) {
                        delete item.item.addToDataBefore
                        delete item.item.addToDataAfter
                        var newItem = _.merge({}, item.item, replacement)
                        this.data.push(newItem)
                    }
                }
            },
            getOrderNextVal (startFrom) {
                if (startFrom) {
                    let fromStr = startFrom.split('')
                    let aChar = fromStr[0] ? fromStr[0].charCodeAt(0) : 34
                    let bChar = fromStr[1] ? fromStr[1].charCodeAt(0) : 34
                    if (aChar > this.orderChars[0]) this.orderChars[0] = aChar
                    if (bChar > this.orderChars[1]) this.orderChars[1] = bChar
                }
                this.orderChars[0] = this.orderChars[0] + 1
                if (this.orderChars[0] === 126) {
                    this.orderChars[1] = this.orderChars[1] + 1
                    this.orderChars[0] = 34
                }
                return String.fromCharCode(this.orderChars[0]) + String.fromCharCode(this.orderChars[1])
            },
            getOrderMidVal (aWord, bWord) {
                if (aWord === null || aWord === '') aWord = '!!'
                let aChars = aWord.split('')
                let bChars = bWord.split('')
                var cWord = ''
                let charCount = aChars.length > bChars.length ? aChars.length : bChars.length
                for (var i = 0; i < charCount + 1; i++) {
                    let aChar = aChars[i] ? aChars[i].charCodeAt(0) : 33
                    let bChar = bChars[i] ? bChars[i].charCodeAt(0) : 126
                    let cChar = Math.floor((aChar + bChar) / 2)
                    cWord += String.fromCharCode(cChar)
                    if (cChar !== aChar && cChar !== bChar) {
                        i = charCount + 1
                    }
                }
                return cWord
            },
            getOrder (oriNode, oriItem, position) {
                var newOrder = 'AA'
                if (this.orderFieldName !== '') {
                    if (position === '2') {
                        if (oriItem.children.length > 0) {
                            var lastItem = oriItem.children[oriItem.children.length - 1]
                            if (lastItem[this.orderFieldName]) {
                                newOrder = this.getOrderNextVal(lastItem[this.orderFieldName])
                            }
                        } else {
                            newOrder = this.getOrderNextVal()
                        }
                    } else if (oriNode && oriNode.parentItem) {
                        // Find position of destination item in the parent group
                        var oriIndex = oriNode.parentItem.indexOf(oriItem)

                        if (position === '1') {
                            // Figure out position
                            if (oriIndex === 0) {
                                // Droped on the top of the list. Get order based on existing first item
                                newOrder = this.getOrderMidVal(null, oriItem[this.orderFieldName])
                            } else {
                                // Droped on item between first and last. Use above and below item order to calculate new order
                                var itemAbove2 = oriNode.parentItem[oriIndex - 1]
                                var itemBelow2 = oriNode.parentItem[oriIndex]
                                newOrder = this.getOrderMidVal(itemAbove2[this.orderFieldName], itemBelow2[this.orderFieldName])
                            }
                        } else if (position === '3') {
                            // Figure out position
                            if (oriIndex === oriNode.parentItem.length - 1) {
                                // Droped at the end of the list. Get order based on existing last item
                                var endItem = oriNode.parentItem[oriNode.parentItem.length - 1]
                                if (endItem[this.orderFieldName]) {
                                    newOrder = this.getOrderNextVal(endItem[this.orderFieldName])
                                }
                            } else {
                                // Droped on item between first and last. Use above and below item order to calculate new order
                                var itemAbove = oriNode.parentItem[oriIndex]
                                var itemBelow = oriNode.parentItem[oriIndex + 1]
                                newOrder = this.getOrderMidVal(itemAbove[this.orderFieldName], itemBelow[this.orderFieldName])
                            }
                        }
                    } else if (oriItem) {
                        newOrder = this.getOrderNextVal(null, oriItem[this.orderFieldName])
                    }
                }
                return newOrder
            },
            onItemDrop (e, oriNode, oriItem, position) {

                if (!this.draggable) return false
                if (this.draggedItem && oriItem[this.childrenFieldName] !== this.draggedItem.item[this.childrenFieldName]) {

                    var newOrder = this.getOrder(oriNode, oriItem, position)
                    var newParent = ''
                    if (position === '2') {
                        /** Item is droped on the other item (folder) ****/
                        if (!this.allowedToDrop(oriItem, position)) return
                        oriItem.children = oriItem.children ? oriItem.children.concat(this.draggedItem.item) : [this.draggedItem.item]
                        oriItem.opened = true
                        newParent = oriItem[this.childrenFieldName]

                        var self = Object.assign({}, this)
                        this.$nextTick(() => {
                            self.draggedItem.parentItem.splice(self.draggedItem.index, 1)
                        })


                        this.$emit('item-drop', oriNode, oriItem, this.draggedItem.item, changeObj,e)


                    }
                    else if (oriNode.parentItem) {
                        /** Item is droped before or under existing item ****/



                        if (oriNode.parentId) newParent = oriNode.parentId
                        // Find position of destination item in the parent group
                        var oriIndex = oriNode.parentItem.indexOf(oriItem)
                        var anchor_modificator = '';
                        if (position === '1') {
                            //before anchor node



                            anchor_modificator = "-left";
                        }
                        else if (position === '3') {
                            //after anchor node



                            anchor_modificator = "-right";

                        }

                        // If order is changed, update item
                        var changeObj = {}
                        if (this.orderFieldName !== '' && newOrder !== '') {

                            if (this.draggedItem.item[this.childrenFieldName]) this.mapCollapsed[this.draggedItem.item[this.childrenFieldName]][this.orderFieldName] = newOrder
                            changeObj[this.orderFieldName] = newOrder
                        }
                        if (newParent !== '') {

                            changeObj[this.parentFieldName] = newParent
                        }


                        this.$emit('item-drop-sibling'+anchor_modificator, oriNode, oriItem, this.draggedItem.item, changeObj,oriIndex,e)

                        _.assign(this.draggedItem.item, changeObj)
                        this.replaceDataItem(this.draggedItem.item, changeObj)

                        this.draggedItem.item.obj = _.merge({}, this.draggedItem.item.obj, changeObj)
                    }

                }
            }
        },
        created() {
            this.initializeData(this.data)
        },
        mounted() {
            if (this.async) {
                this.$set(this.data, 0, this.initializeLoading())
                this.handleAsyncLoad(this.data, this)
            }
        },
        components: {
            TreeItem
        }
    }
</script>
<style lang="less">
    @import "./less/style";
</style>
